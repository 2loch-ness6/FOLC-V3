#!/bin/sh
################################################################################
# ORBITAL OS INIT SCRIPT
# 
# Purpose: Clean init.d-style service script for Orbic Speed (RC400L) root
#          integration. Replaces the service hijack approach with proper
#          init script structure.
#
# Location: /data/rayhunter/rayhunter-daemon (replaces vendor binary)
# 
# Author: FOLC-V3 Project / Copilot Architect
# Version: 1.0
# Date: January 2026
#
# Usage: 
#   orbital_os_init.sh start   - Start all services
#   orbital_os_init.sh stop    - Stop all services  
#   orbital_os_init.sh restart - Restart all services
#   orbital_os_init.sh status  - Check service status
#   orbital_os_init.sh test    - Test without making changes
#
################################################################################

# Configuration
ALPINE_ROOT="/data/alpine"
LOG_FILE="/data/rayhunter/orbital_os.log"
PID_FILE="/data/rayhunter/orbital_os.pid"
BACKDOOR_PORT=9999
FOAC_SCRIPT="/data/rayhunter/start_foac_v2.sh"
ORIGINAL_DAEMON="/data/rayhunter/rayhunter-daemon.bak"
SYMLINK_BRIDGE="/data/rayhunter/symlink_bridge.sh"

# Color codes for logging (if terminal supports it)
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

################################################################################
# Logging Functions
################################################################################

log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" | tee -a "$LOG_FILE"
}

log_success() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] ${GREEN}[+]${NC} $1" | tee -a "$LOG_FILE"
}

log_error() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] ${RED}[-]${NC} $1" | tee -a "$LOG_FILE"
}

log_warning() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] ${YELLOW}[!]${NC} $1" | tee -a "$LOG_FILE"
}

log_info() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] [*] $1" | tee -a "$LOG_FILE"
}

################################################################################
# Mount Management
################################################################################

mount_alpine_filesystems() {
    log_info "Mounting Alpine chroot filesystems..."
    
    # Verify Alpine root exists
    if [ ! -d "$ALPINE_ROOT" ]; then
        log_error "Alpine root directory $ALPINE_ROOT does not exist!"
        return 1
    fi
    
    # Unmount any existing mounts (clean slate)
    umount "$ALPINE_ROOT/proc" 2>/dev/null
    umount "$ALPINE_ROOT/sys" 2>/dev/null  
    umount "$ALPINE_ROOT/dev" 2>/dev/null
    
    # Mount /proc
    if ! mount -t proc proc "$ALPINE_ROOT/proc" 2>/dev/null; then
        log_error "Failed to mount /proc"
        return 1
    fi
    log_success "Mounted /proc"
    
    # Mount /sys
    if ! mount -t sysfs sys "$ALPINE_ROOT/sys" 2>/dev/null; then
        log_error "Failed to mount /sys"
        return 1
    fi
    log_success "Mounted /sys"
    
    # Mount /dev (bind mount)
    if ! mount -o bind /dev "$ALPINE_ROOT/dev" 2>/dev/null; then
        log_error "Failed to mount /dev"
        return 1
    fi
    log_success "Mounted /dev"
    
    log_success "All Alpine filesystems mounted successfully"
    return 0
}

umount_alpine_filesystems() {
    log_info "Unmounting Alpine chroot filesystems..."
    
    umount "$ALPINE_ROOT/dev" 2>/dev/null && log_success "Unmounted /dev"
    umount "$ALPINE_ROOT/sys" 2>/dev/null && log_success "Unmounted /sys"
    umount "$ALPINE_ROOT/proc" 2>/dev/null && log_success "Unmounted /proc"
    
    log_success "Alpine filesystems unmounted"
    return 0
}

check_mounts() {
    log_info "Checking Alpine filesystem mounts..."
    
    local all_mounted=true
    
    if mount | grep -q "$ALPINE_ROOT/proc"; then
        log_success "/proc is mounted"
    else
        log_error "/proc is NOT mounted"
        all_mounted=false
    fi
    
    if mount | grep -q "$ALPINE_ROOT/sys"; then
        log_success "/sys is mounted"
    else
        log_error "/sys is NOT mounted"
        all_mounted=false
    fi
    
    if mount | grep -q "$ALPINE_ROOT/dev"; then
        log_success "/dev is mounted"
    else
        log_error "/dev is NOT mounted"
        all_mounted=false
    fi
    
    if [ "$all_mounted" = true ]; then
        return 0
    else
        return 1
    fi
}

################################################################################
# Symlink Bridge Integration
################################################################################

setup_symlink_bridge() {
    log_info "Setting up symlink bridge..."
    
    if [ ! -f "$SYMLINK_BRIDGE" ]; then
        log_warning "Symlink bridge script not found at $SYMLINK_BRIDGE"
        log_warning "Skipping symlink bridge setup"
        return 0
    fi
    
    if [ ! -x "$SYMLINK_BRIDGE" ]; then
        log_warning "Symlink bridge script is not executable, fixing permissions"
        chmod +x "$SYMLINK_BRIDGE"
    fi
    
    # Execute the symlink bridge script
    if "$SYMLINK_BRIDGE" setup >> "$LOG_FILE" 2>&1; then
        log_success "Symlink bridge configured successfully"
        return 0
    else
        log_warning "Symlink bridge setup encountered issues (non-fatal)"
        return 0
    fi
}

################################################################################
# Backdoor Service Management
################################################################################

start_backdoor() {
    log_info "Starting root backdoor service on port $BACKDOOR_PORT..."
    
    # Check if backdoor is already running
    if netstat -tlpn 2>/dev/null | grep -q ":$BACKDOOR_PORT "; then
        log_warning "Backdoor already running on port $BACKDOOR_PORT"
        return 0
    fi
    
    # Start persistent backdoor using busybox netcat
    # This creates a loop that restarts netcat if it dies
    (
        while true; do
            /bin/busybox nc -ll -p $BACKDOOR_PORT -e /bin/sh 2>/dev/null
            sleep 1
        done
    ) &
    
    local backdoor_pid=$!
    
    # Give it a moment to start
    sleep 2
    
    # Verify it started
    if netstat -tlpn 2>/dev/null | grep -q ":$BACKDOOR_PORT "; then
        log_success "Backdoor service started successfully (PID: $backdoor_pid)"
        echo $backdoor_pid > "${PID_FILE}.backdoor"
        return 0
    else
        log_error "Backdoor service failed to start"
        return 1
    fi
}

stop_backdoor() {
    log_info "Stopping backdoor service..."
    
    # Kill all netcat processes listening on our port
    local pids=$(netstat -tlpn 2>/dev/null | grep ":$BACKDOOR_PORT " | awk '{print $7}' | cut -d'/' -f1)
    
    if [ -n "$pids" ]; then
        for pid in $pids; do
            if [ -n "$pid" ] && [ "$pid" -gt 0 ]; then
                kill "$pid" 2>/dev/null && log_success "Killed backdoor process (PID: $pid)"
            fi
        done
    else
        log_warning "No backdoor processes found"
    fi
    
    # Clean up PID file
    rm -f "${PID_FILE}.backdoor"
    
    return 0
}

check_backdoor() {
    if netstat -tlpn 2>/dev/null | grep -q ":$BACKDOOR_PORT "; then
        log_success "Backdoor service is running on port $BACKDOOR_PORT"
        return 0
    else
        log_error "Backdoor service is NOT running"
        return 1
    fi
}

################################################################################
# FOAC UI Management
################################################################################

start_foac_ui() {
    log_info "Starting FOAC UI..."
    
    if [ ! -f "$FOAC_SCRIPT" ]; then
        log_warning "FOAC startup script not found at $FOAC_SCRIPT"
        log_warning "Skipping FOAC UI (non-critical)"
        return 0
    fi
    
    if [ ! -x "$FOAC_SCRIPT" ]; then
        log_warning "FOAC script is not executable, fixing permissions"
        chmod +x "$FOAC_SCRIPT"
    fi
    
    # Launch FOAC UI in background
    /bin/sh "$FOAC_SCRIPT" >> "$LOG_FILE" 2>&1 &
    local foac_pid=$!
    
    log_success "FOAC UI started (PID: $foac_pid)"
    echo $foac_pid > "${PID_FILE}.foac"
    
    return 0
}

stop_foac_ui() {
    log_info "Stopping FOAC UI..."
    
    if [ -f "${PID_FILE}.foac" ]; then
        local pid=$(cat "${PID_FILE}.foac")
        if [ -n "$pid" ] && [ "$pid" -gt 0 ]; then
            if kill "$pid" 2>/dev/null; then
                log_success "FOAC UI stopped (PID: $pid)"
            else
                log_warning "Could not stop FOAC UI (PID: $pid) - may have already exited"
            fi
        fi
        rm -f "${PID_FILE}.foac"
    else
        log_warning "FOAC UI PID file not found"
    fi
    
    # Also try to kill any Python UI processes
    killall -q python3 2>/dev/null
    
    return 0
}

################################################################################
# Original Daemon Management
################################################################################

start_original_daemon() {
    log_info "Starting original rayhunter daemon..."
    
    if [ ! -f "$ORIGINAL_DAEMON" ]; then
        log_warning "Original daemon not found at $ORIGINAL_DAEMON"
        log_warning "This is normal if daemon was never backed up"
        return 0
    fi
    
    if [ ! -x "$ORIGINAL_DAEMON" ]; then
        log_warning "Original daemon is not executable, fixing permissions"
        chmod +x "$ORIGINAL_DAEMON"
    fi
    
    # Execute the original daemon with any passed arguments
    # Use exec to replace current process (if called directly)
    # Or run in background if called from wrapper
    if [ "$1" = "exec" ]; then
        log_info "Executing original daemon (exec mode)"
        exec "$ORIGINAL_DAEMON" "$@"
    else
        log_info "Starting original daemon in background"
        "$ORIGINAL_DAEMON" "$@" &
        log_success "Original daemon started"
    fi
    
    return 0
}

################################################################################
# Service Control Functions
################################################################################

do_start() {
    log "=========================================="
    log "ORBITAL OS INIT - START"
    log "=========================================="
    
    # Step 1: Mount Alpine filesystems
    if ! mount_alpine_filesystems; then
        log_error "Failed to mount Alpine filesystems"
        return 1
    fi
    
    # Step 2: Setup symlink bridge
    setup_symlink_bridge
    
    # Step 3: Start backdoor service
    if ! start_backdoor; then
        log_error "Failed to start backdoor service"
        return 1
    fi
    
    # Step 4: Start FOAC UI (non-critical)
    start_foac_ui
    
    # Step 5: Start original daemon (if it exists)
    start_original_daemon "$@"
    
    log_success "Orbital OS initialization complete"
    log "=========================================="
    
    return 0
}

do_stop() {
    log "=========================================="
    log "ORBITAL OS INIT - STOP"
    log "=========================================="
    
    # Stop FOAC UI
    stop_foac_ui
    
    # Stop backdoor
    stop_backdoor
    
    # Unmount Alpine filesystems
    umount_alpine_filesystems
    
    log_success "Orbital OS shutdown complete"
    log "=========================================="
    
    return 0
}

do_restart() {
    log "=========================================="
    log "ORBITAL OS INIT - RESTART"
    log "=========================================="
    
    do_stop
    sleep 2
    do_start "$@"
    
    return 0
}

do_status() {
    log "=========================================="
    log "ORBITAL OS INIT - STATUS CHECK"
    log "=========================================="
    
    local status=0
    
    # Check mounts
    if ! check_mounts; then
        status=1
    fi
    
    # Check backdoor
    if ! check_backdoor; then
        status=1
    fi
    
    # Check if Alpine chroot is accessible
    if [ -d "$ALPINE_ROOT" ]; then
        log_success "Alpine root directory exists"
    else
        log_error "Alpine root directory NOT found"
        status=1
    fi
    
    # System information
    log_info "System Information:"
    log_info "  UID: $(id -u)"
    log_info "  User: $(id -un)"
    log_info "  Capabilities: $(grep CapEff /proc/self/status 2>/dev/null | awk '{print $2}')"
    
    log "=========================================="
    
    if [ $status -eq 0 ]; then
        log_success "All systems operational"
    else
        log_error "Some systems are not operational"
    fi
    
    return $status
}

do_test() {
    log "=========================================="
    log "ORBITAL OS INIT - TEST MODE"
    log "=========================================="
    
    log_info "This is a non-destructive test of the init script"
    log_info "No actual changes will be made to the system"
    
    # Test 1: Check if we're running as root
    if [ "$(id -u)" -eq 0 ]; then
        log_success "Running as root (UID 0)"
    else
        log_error "NOT running as root (UID: $(id -u))"
    fi
    
    # Test 2: Check if Alpine root exists
    if [ -d "$ALPINE_ROOT" ]; then
        log_success "Alpine root directory exists: $ALPINE_ROOT"
    else
        log_error "Alpine root directory NOT found: $ALPINE_ROOT"
    fi
    
    # Test 3: Check if we can write to log file
    if touch "$LOG_FILE" 2>/dev/null; then
        log_success "Log file is writable: $LOG_FILE"
    else
        log_error "Cannot write to log file: $LOG_FILE"
    fi
    
    # Test 4: Check if busybox nc is available
    if which busybox >/dev/null 2>&1 && busybox nc --help >/dev/null 2>&1; then
        log_success "Busybox netcat is available"
    else
        log_error "Busybox netcat NOT available"
    fi
    
    # Test 5: Check if original daemon exists
    if [ -f "$ORIGINAL_DAEMON" ]; then
        log_success "Original daemon found: $ORIGINAL_DAEMON"
    else
        log_warning "Original daemon not found: $ORIGINAL_DAEMON"
    fi
    
    # Test 6: Check if symlink bridge exists
    if [ -f "$SYMLINK_BRIDGE" ]; then
        log_success "Symlink bridge script found: $SYMLINK_BRIDGE"
    else
        log_warning "Symlink bridge script not found: $SYMLINK_BRIDGE"
    fi
    
    log "=========================================="
    log_success "Test mode complete - review results above"
    log "=========================================="
    
    return 0
}

################################################################################
# Main Entry Point
################################################################################

main() {
    # Parse command
    case "${1:-start}" in
        start)
            do_start "$@"
            ;;
        stop)
            do_stop
            ;;
        restart)
            do_restart "$@"
            ;;
        status)
            do_status
            ;;
        test)
            do_test
            ;;
        *)
            echo "Usage: $0 {start|stop|restart|status|test}"
            echo ""
            echo "Commands:"
            echo "  start   - Start Orbital OS services"
            echo "  stop    - Stop Orbital OS services"
            echo "  restart - Restart Orbital OS services"
            echo "  status  - Check service status"
            echo "  test    - Run non-destructive tests"
            exit 1
            ;;
    esac
    
    return $?
}

# Execute main function
main "$@"
exit $?
